File 'unittest1.c'
Lines executed:88.89% of 18
Creating 'unittest1.c.gcov'

File 'unittest2.c'
Lines executed:97.56% of 41
Creating 'unittest2.c.gcov'

File 'unittest3.c'
Lines executed:100.00% of 11
Creating 'unittest3.c.gcov'

File 'unittest4.c'
Lines executed:87.50% of 16
Creating 'unittest4.c.gcov'

File 'cardtest1.c'
Lines executed:81.25% of 32
Creating 'cardtest1.c.gcov'

File 'cardtest2.c'
Lines executed:95.45% of 22
Creating 'cardtest2.c.gcov'

File 'cardtest3.c'
Lines executed:77.14% of 35
Creating 'cardtest3.c.gcov'

File 'cardtest4.c'
Lines executed:77.14% of 35
Creating 'cardtest4.c.gcov'

        -:    0:Source:unittest1.c
        -:    0:Graph:unittest1.gcno
        -:    0:Data:unittest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:	
        -:    2://isGameOver test
        -:    3:  
        -:    4:#include "dominion.h"
        -:    5:#include "dominion_helpers.h"
        -:    6:#include "rngs.h"
        -:    7:#include <stdio.h>
        -:    8:#include <math.h>
        -:    9:#include <stdlib.h>
        -:   10:
        -:   11:
        1:   12:int main () {
        -:   13:
        -:   14:	
        1:   15:	int passes = 0; int fails = 0; // keeps track of case results 
        1:   16:	int tpass = 0;	int tfail = 0;// totals
        -:   17:
        -:   18:	//initalize a fake gamestate
        -:   19:	struct gameState G;
        1:   20:	struct gameState *p = &G;
        1:   21:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse, 
        -:   22:	       sea_hag, tribute, smithy};
        1:   23:  	initializeGame(2, k, 7, p);
        -:   24:
        -:   25:	
        -:   26:	////Test for false positives/////
        -:   27:	/////////////////////////////////
        1:   28:	int cases = 1000; //how many random numbers will be tested	
     1001:   29:	for(int i=0; i<cases; i++){
        -:   30:		
     1000:   31:		int player = rand()%4;
     1000:   32:		int random = rand()%(MAX_HAND);
        -:   33:		
     1000:   34:		p->whoseTurn=player;
     1000:   35:		p->handCount[player]=random;
        -:   36:		
     1000:   37:		int answer = numHandCards(p);
        -:   38:		
     1000:   39:		if(answer == random ){passes++;}
        -:   40:		else{
    #####:   41:			fails++; 
    #####:   42:			printf("\nFailure on player %d, returned: %d should be %d",player,answer,random);
        -:   43:		}
        -:   44:		
        -:   45:		
        -:   46:	}
        -:   47:
        -:   48:
        -:   49:
        -:   50:	//result output
        1:   51:			printf("\n\n            Test Complete: %d total passes,  %d total fails\n\n\n",passes,fails);
        -:   52:	
        -:   53:
        -:   54:
        1:   55:return 0;
        -:   56:}
        -:   57:
        -:    0:Source:unittest2.c
        -:    0:Graph:unittest2.gcno
        -:    0:Data:unittest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2://isGameOver test
        -:    3:  
        -:    4:#include "dominion.h"
        -:    5:#include "dominion_helpers.h"
        -:    6:#include "rngs.h"
        -:    7:#include <stdio.h>
        -:    8:#include <math.h>
        -:    9:#include <stdlib.h>
        -:   10:
        -:   11:
        1:   12:int main () {
        -:   13:
        -:   14:	
        1:   15:	int passes = 0; int fails = 0; // keeps track of case results 
        1:   16:	int tpass = 0;	int tfail = 0;// totals
        -:   17:
        -:   18:	//initalize a fake gamestate
        -:   19:	struct gameState G;
        1:   20:	struct gameState *p = &G;
        1:   21:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse, 
        -:   22:	       sea_hag, tribute, smithy};
        1:   23:  	initializeGame(2, k, 7, p);
        -:   24:
        -:   25:	
        -:   26:	////Test for false positives/////
        -:   27:	/////////////////////////////////
        1:   28:	int cases = 1000; //how many random numbers will be tested	
     1001:   29:	for(int i=0; i<cases; i++){
        -:   30:		int testSupply[treasure_map+1];
     1000:   31:		for(int i=0;i<treasure_map;i++){testSupply[i] = rand()%11 + 1;}
     1000:   32:		for(int i=0;i<treasure_map;i++){p->supplyCount[i] = testSupply[i];}	
        -:   33:			
     1000:   34:		int x=isGameOver(p);
        -:   35:			
     1000:   36:		if(x==0){passes++; }
     1000:   37:		if(x==1){fails++; }
        -:   38:	
        -:   39:	}		
        1:   40:	printf("\n\n False Positive Test Complete: %d passes,  %d fails",passes,fails);
        1:   41:	tpass=tpass+passes; tfail=tfail+fails;
        1:   42:	passes = 0; fails = 0;	
        -:   43:	
        -:   44:	
        -:   45:	
        -:   46:	////Test for 0 province detection/////
        -:   47:	/////////////////////////////////
        -:   48:		
     1001:   49:	for(int i=0; i<cases; i++){
        -:   50:		int testSupply[treasure_map+1];
     1000:   51:		for(int i=0;i<treasure_map;i++){testSupply[i] = rand()%11 + 1;}
     1000:   52:		for(int i=0;i<treasure_map;i++){p->supplyCount[i] = testSupply[i];}	
        -:   53:		
     1000:   54:		int pcard = rand()%2;
     1000:   55:		p->supplyCount[province] = pcard;
        -:   56:		
     1000:   57:		int x=isGameOver(p);
        -:   58:			
     1000:   59:		if((x==0&&pcard==1)||(x==1&&pcard==0)){passes++;}
    #####:   60:		else{fails++;}
        -:   61:		
        -:   62:	}		
        1:   63:	printf("\n\n 0 province Test Complete: %d passes,  %d fails",passes,fails);
        1:   64:	tpass=tpass+passes; tfail=tfail+fails;
        1:   65:	passes = 0; fails = 0;
        -:   66:	
        -:   67:	
        -:   68:	
        -:   69:	////Test for three 0 detection/////
        -:   70:	/////////////////////////////////
        -:   71:		
     1001:   72:	for(int i=0; i<cases; i++){
     1000:   73:		for(int i=0;i<treasure_map;i++){p->supplyCount[i] = rand()%13;}
     1000:   74:		p->supplyCount[province] = 1;
        -:   75:		
     1000:   76:		int game0count=0;
        -:   77:
        -:   78:		
     1000:   79:		for(int i=0;i<treasure_map;i++){if(p->supplyCount[i] ==0){game0count++;}}
        -:   80:			
        -:   81:		
        -:   82:		
     1000:   83:		int x=isGameOver(p);
        -:   84:		
     1000:   85:		if((x==0&&game0count<3)||(x==1&&game0count>2)){
      982:   86:			passes++;
        -:   87:			//printf("\nPass x: %d count: %d  Supply: %d",x,game0count, treasure_map);
        -:   88:			//for(int i=0;i<treasure_map;i++){printf("%d ",p->supplyCount[i]);}
        -:   89:		}
        -:   90:		else{
       18:   91:			fails++;
        -:   92:			//printf("\nFail x: %d count: %d  Supply: %d",x,game0count, treasure_map);
        -:   93:			//for(int i=0;i<treasure_map;i++){printf("%d ",p->supplyCount[i]);}
        -:   94:		}
        -:   95:	}		
        1:   96:	printf("\n\n Three 0 Test Complete: %d passes,  %d fails\n\n",passes,fails);
        1:   97:	tpass=tpass+passes; tfail=tfail+fails;
        1:   98:	passes = 0; fails = 0;
        -:   99:
        -:  100:
        -:  101:	//result output
        1:  102:			printf("\n\n            Test Complete: %d total passes,  %d total fails\n\n\n",tpass,tfail);
        -:  103:	
        -:  104:
        -:  105:
        1:  106:return 0;
        -:  107:}
        -:  108:
        -:    0:Source:unittest3.c
        -:    0:Graph:unittest3.gcno
        -:    0:Data:unittest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1://KingdomCards test
        -:    2:  
        -:    3:#include "dominion.h"
        -:    4:#include "dominion_helpers.h"
        -:    5:#include "rngs.h"
        -:    6:#include <stdio.h>
        -:    7:#include <math.h>
        -:    8:#include <stdlib.h>
        -:    9:
        -:   10:
        1:   11:int main () {
        -:   12:
        -:   13:	
        1:   14:	int passes = 0; int fails = 0; // keeps track of case results
        -:   15:
        -:   16:	
        -:   17:	//The test
        1:   18:	int cases = 1000; //how many random numbers will be tested	
     1001:   19:	for(int i=0; i<cases; i++){	
        -:   20:	
        -:   21:
        -:   22:		
        -:   23:		
        -:   24:		int testK[10];
     1000:   25:		for(int i=0;i<10;i++){testK[i]=(rand()%19+7);}
        -:   26:	
     1000:   27:		int* kings=kingdomCards((testK[0]),testK[1],testK[2],testK[3],testK[4],testK[5],testK[6],testK[7],testK[8],testK[9]);
        -:   28:	
    11000:   29:		for(int i = 0; i<10;i++ ){
    10000:   30:			if(testK[i]!=kings[i]){fails++; break;}
    10000:   31:			else if(testK[i]==kings[i] && i==9){passes++;}
        -:   32:			
        -:   33:			
        -:   34:			//printf("\n   %d    %d   ", testK[i],kings[i]);
        -:   35:		}
        -:   36:		
        -:   37:		//printf("\n\n");
        -:   38:	}
        -:   39:	
        -:   40:	
        1:   41:		printf("\n\nPasses: %d   Fails: %d\n\n",passes,fails);
        -:   42:
        -:   43:
        1:   44:return 0;
        -:   45:}
        -:   46:
        -:    0:Source:unittest4.c
        -:    0:Graph:unittest4.gcno
        -:    0:Data:unittest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* This is a unit test for the whoseTurn() functions
        -:    2: *	sets a value to whoesturn in the gameState 
        -:    3: *	then compares it to the return of the function
        -:    4: *	whoseTurn(). this test does not fail invalid 
        -:    5: *	number of players because the function does not 
        -:    6: *	specify that it is supposed to do so.
        -:    7: *
        -:    8: */
        -:    9:  
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <stdio.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:
        1:   18:int main () {
        -:   19:
        1:   20:int values[27]={0,2,5,8,0,3,6,6,5,4,4,5,4,4,3,4,3,5,3,5,3,4,2,5,4,4,4};
        -:   21:
        -:   22:	
        1:   23:	int passes = 0; int fails = 0; // keeps track of case results
        -:   24:
        -:   25:	
        -:   26:	//The test
        1:   27:	int cases = 1000; //how many random numbers will be tested	
     1001:   28:	for(int i=0; i<cases; i++){	
        -:   29:	
     1000:   30:		int x = (rand()%36)-5;
        -:   31:		
        -:   32:		
     1000:   33:		int cost = getCost(x);
        -:   34:		
     1751:   35:		if((x>=0)&&(x<=26)){
      751:   36:			int test =values[x];
      751:   37:			if(cost==test){passes++;}
    #####:   38:			else{fails++;}
        -:   39:		}
      249:   40:		else if((x<0)||(x>26)){
      249:   41:			if(cost==-1){passes++;}
    #####:   42:			else{fails++; printf("returned %d  given %d\n",cost, x);}
        -:   43:		}
        -:   44:		
        -:   45:	}
        -:   46:	
        1:   47:	printf("Passes %d  Fails %d",passes, fails);
        -:   48:
        1:   49:return 0;
        -:   50:}
        -:   51:
        -:    0:Source:cardtest1.c
        -:    0:Graph:cardtest1.gcno
        -:    0:Data:cardtest1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* This is a unit test for the whoseTurn() functions
        -:    2: *	sets a value to whoesturn in the gameState 
        -:    3: *	then compares it to the return of the function
        -:    4: *	whoseTurn(). this test does not fail invalid 
        -:    5: *	number of players because the function does not 
        -:    6: *	specify that it is supposed to do so.
        -:    7: *
        -:    8: */
        -:    9:  
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <stdio.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:
        1:   18:int main () {
        -:   19:
        -:   20:	
        1:   21:	int passes = 0; int fails = 0; // keeps track of case results
        -:   22:
        -:   23:	//initalize a fake gamestate
        -:   24:	struct gameState G;
        1:   25:	struct gameState *p = &G;
        1:   26:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse, 
        -:   27:	       sea_hag, tribute, smithy};
        1:   28:  	initializeGame(2, k, 7, p);
        -:   29:
        -:   30:	
        -:   31:	//The test
        1:   32:	int cases = 1000; //how many random numbers will be tested	
     1001:   33:	for(int i=0; i<cases; i++){
        -:   34:
        -:   35:		
     1000:   36:		p->whoseTurn=rand()%4;
     1000:   37:		int player = p->whoseTurn;
        -:   38:		
     1000:   39:		int cardsInDeck = rand()%10;
     1000:   40:		int cardsInHand = rand()%5+1;
        -:   41:
        -:   42:		
     1000:   43:		for(int i = 0 ; i<cardsInDeck; i++){p->deck[player][i] = rand()%27;}
     1000:   44:		for(int i = 0 ; i<cardsInHand; i++){p->hand[player][i] = rand()%27;}
        -:   45:		
        -:   46:		
        -:   47:		
     1000:   48:		p->deckCount[player] = cardsInDeck;
        -:   49:		
     1000:   50:		int smithyLocation = rand()%cardsInHand;
     1000:   51:		p->hand[player][smithyLocation]=smithy;
     1000:   52:		p->handCount[player]=cardsInHand;
        -:   53:		
        -:   54:		
        -:   55:		int handBefore, handAfter, deckBefore, deckAfter;
        -:   56:		
     1000:   57:		handBefore = p->handCount[player];
     1000:   58:		deckBefore = p->deckCount[player];
        -:   59:		
     1000:   60:		SmithyCard( p, player, smithyLocation);
        -:   61:		
     1000:   62:		handAfter = p->handCount[player];
     1000:   63:		deckAfter = p->deckCount[player];	
        -:   64:		
     1000:   65:		if((handAfter==handBefore+2) && (deckBefore == deckAfter + 3)){passes++;}
      332:   66:		else if(deckAfter == 0 && handAfter == handBefore + deckBefore -1){passes++;}
        -:   67:		else{
    #####:   68:			fails++;
        -:   69:		
    #####:   70:			printf("\nFailure: test %d", i);
    #####:   71:			printf("\nbefore call handCount = %d   ", handBefore);
    #####:   72:			printf("deckCount = %d   \n",deckBefore);
        -:   73:		
    #####:   74:			printf("after call handCount = %d   ", handAfter);
    #####:   75:			printf("deckCount = %d   \n", deckAfter);
        -:   76:		}
        -:   77:	
        -:   78:	
        -:   79:	
        -:   80:	}
        -:   81:	
        -:   82:	
        -:   83:		
        -:   84:			//result output
        1:   85:			printf("\n\n Test Complete: %d passes,  %d fails",passes,fails);
        -:   86:	
        -:   87:
        -:   88:
        1:   89:return 0;
        -:   90:}
        -:   91:
        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* This is a unit test for the whoseTurn() functions
        -:    2: *	sets a value to whoesturn in the gameState 
        -:    3: *	then compares it to the return of the function
        -:    4: *	whoseTurn(). this test does not fail invalid 
        -:    5: *	number of players because the function does not 
        -:    6: *	specify that it is supposed to do so.
        -:    7: *
        -:    8: */
        -:    9:  
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <stdio.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:
        1:   18:int main () {
        -:   19:
        -:   20:	
        1:   21:	int passes = 0; int fails = 0; // keeps track of case results
        -:   22:
        -:   23:	//initalize a fake gamestate
        -:   24:	struct gameState G;
        1:   25:	struct gameState *p = &G;
        1:   26:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse, 
        -:   27:	       sea_hag, tribute, smithy};
        1:   28:  	initializeGame(2, k, 7, p);
        -:   29:
        -:   30:	
        -:   31:	//The test
        1:   32:	int cases = 1000; //how many random numbers will be tested	
     1001:   33:	for(int i=0; i<cases; i++){
        -:   34:
        -:   35:		
     1000:   36:		p->whoseTurn=rand()%4;
     1000:   37:		int player = p->whoseTurn;
        -:   38:		
     1000:   39:		int cardsInDeck = rand()%10;
     1000:   40:		int cardsInHand = rand()%5+1;
        -:   41:
        -:   42:		
     1000:   43:		for(int i = 0 ; i<cardsInDeck; i++){p->deck[player][i] = rand()%27;}
     1000:   44:		for(int i = 0 ; i<cardsInHand; i++){p->hand[player][i] = rand()%27;}
        -:   45:		
        -:   46:		
        -:   47:		
     1000:   48:		p->deckCount[player] = cardsInDeck;
        -:   49:		
     1000:   50:		int outpostLocation = rand()%cardsInHand;
     1000:   51:		p->hand[player][outpostLocation]=outpost;
     1000:   52:		p->handCount[player]=cardsInHand;
        -:   53:		
     1000:   54:		cardEffect(outpost, 0,0,0, p, outpostLocation, 0);
        -:   55:		
     1000:   56:		if(p->outpostPlayed){passes++;}
    #####:   57:		else{fails++;}
        -:   58:		
        -:   59:
        -:   60:		
        -:   61:		
        -:   62:	
        -:   63:	
        -:   64:	
        -:   65:	}
        -:   66:	
        -:   67:	
        -:   68:		
        -:   69:			//result output
        1:   70:			printf("\n\n Test Complete: %d passes,  %d fails",passes,fails);
        -:   71:	
        -:   72:
        -:   73:
        1:   74:return 0;
        -:   75:}
        -:   76:
        -:    0:Source:cardtest3.c
        -:    0:Graph:cardtest3.gcno
        -:    0:Data:cardtest3.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* This is a unit test for the whoseTurn() functions
        -:    2: *	sets a value to whoesturn in the gameState 
        -:    3: *	then compares it to the return of the function
        -:    4: *	whoseTurn(). this test does not fail invalid 
        -:    5: *	number of players because the function does not 
        -:    6: *	specify that it is supposed to do so.
        -:    7: *
        -:    8: */
        -:    9:  
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <stdio.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:
        1:   18:int main (){
        -:   19:
        -:   20:	//printf("made it to in main");
        -:   21:	
        1:   22:	int passes = 0; int fails = 0; // keeps track of case results
        -:   23:	
        -:   24:	
        -:   25:	
        -:   26:	//initalize a fake gamestate
        -:   27:	struct gameState G;
        1:   28:	struct gameState *p = &G;
        1:   29:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse, 
        -:   30:	       sea_hag, tribute, smithy};
        -:   31:	
        -:   32:
        1:   33:  	initializeGame(2, k, 7, p);
        -:   34:
        -:   35:	//printf("made it past initalization");
        -:   36:	
        -:   37:	//The test
        1:   38:	int cases = 1000; //how many random numbers will be tested	
     1001:   39:	for(int i=0; i<cases; i++){
        -:   40:
     1000:   41:		int player = 0;
     1000:   42:		int cardsInDeck = rand()%10;
     1000:   43:		int cardsInHand = rand()%5+1;
        -:   44:
        -:   45:		
     1000:   46:		for(int i = 0 ; i<cardsInDeck; i++){p->deck[player][i] = rand()%27;}
     1000:   47:		for(int i = 0 ; i<cardsInHand; i++){p->hand[player][i] = rand()%27;}
        -:   48:		
     1000:   49:		p->deckCount[player] = cardsInDeck;
        -:   50:		
     1000:   51:		int villageLocation = rand()%cardsInHand;
     1000:   52:		p->hand[player][villageLocation]=village;
     1000:   53:		p->handCount[player]=cardsInHand;
        -:   54:		
        -:   55:		
        -:   56:		int handBefore, handAfter, deckBefore, deckAfter, actionsBefore, actionsAfter;
        -:   57:		
     1000:   58:		handBefore = p->handCount[player];
     1000:   59:		deckBefore = p->deckCount[player];
     1000:   60:		actionsBefore = p->numActions;
        -:   61:		
     1000:   62:		cardEffect(village, 0,0,0, p, villageLocation, 0);
        -:   63:		
     1000:   64:		handAfter = p->handCount[player];
     1000:   65:		deckAfter = p->deckCount[player];	
     1000:   66:		actionsAfter = p->numActions;
        -:   67:		
        -:   68:		
     1000:   69:		if((handAfter==handBefore) && (deckBefore == deckAfter + 1) && (actionsAfter == actionsBefore+2)){passes++;}
      102:   70:		else if((deckAfter == 0) && (handAfter == handBefore + deckBefore -1)&&(actionsAfter == actionsBefore+2)){passes++;}
        -:   71:		else{
    #####:   72:			fails++;
        -:   73:		
    #####:   74:			printf("\nFailure: test");
    #####:   75:			printf("\nbefore call handCount = %d   ", handBefore);
    #####:   76:			printf("deckCount = %d   \n",deckBefore);
    #####:   77:			printf("actionCount = %d   \n",actionsBefore);
        -:   78:		
    #####:   79:			printf("after call handCount = %d   ", handAfter);
    #####:   80:			printf("deckCount = %d   \n", deckAfter);
    #####:   81:			printf("actionCount = %d   \n",actionsAfter);
        -:   82:		}
        -:   83:	
        -:   84:	
        -:   85:	
        -:   86:	}
        -:   87:	
        -:   88:	
        -:   89:		
        -:   90:			//result output
        1:   91:			printf("\n\n Test Complete: %d passes,  %d fails",passes,fails);
        -:   92:	
        -:   93:
        -:   94:
        1:   95:return 0;
        -:   96:}
        -:   97:
        -:    0:Source:cardtest4.c
        -:    0:Graph:cardtest4.gcno
        -:    0:Data:cardtest4.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* This is a unit test for the whoseTurn() functions
        -:    2: *	sets a value to whoesturn in the gameState 
        -:    3: *	then compares it to the return of the function
        -:    4: *	whoseTurn(). this test does not fail invalid 
        -:    5: *	number of players because the function does not 
        -:    6: *	specify that it is supposed to do so.
        -:    7: *
        -:    8: */
        -:    9:  
        -:   10:#include "dominion.h"
        -:   11:#include "dominion_helpers.h"
        -:   12:#include "rngs.h"
        -:   13:#include <stdio.h>
        -:   14:#include <math.h>
        -:   15:#include <stdlib.h>
        -:   16:
        -:   17:
        1:   18:int main (){
        -:   19:
        -:   20:	//printf("made it to in main");
        -:   21:	
        1:   22:	int passes = 0; int fails = 0; // keeps track of case results
        -:   23:	
        -:   24:	
        -:   25:	
        -:   26:	//initalize a fake gamestate
        -:   27:	struct gameState G;
        1:   28:	struct gameState *p = &G;
        1:   29:	int k[10] = {adventurer, gardens, embargo, village, minion, mine, cutpurse, 
        -:   30:	       sea_hag, tribute, smithy};
        -:   31:	
        -:   32:
        1:   33:  	initializeGame(2, k, 7, p);
        -:   34:
        -:   35:	//printf("made it past initalization");
        -:   36:	
        -:   37:	//The test
        1:   38:	int cases = 1000; //how many random numbers will be tested	
     1001:   39:	for(int i=0; i<cases; i++){
        -:   40:
     1000:   41:		int player = 0;
     1000:   42:		int cardsInDeck = rand()%10;
     1000:   43:		int cardsInHand = rand()%5+1;
        -:   44:
        -:   45:		
     1000:   46:		for(int i = 0 ; i<cardsInDeck; i++){p->deck[player][i] = rand()%27;}
     1000:   47:		for(int i = 0 ; i<cardsInHand; i++){p->hand[player][i] = rand()%27;}
        -:   48:		
     1000:   49:		p->deckCount[player] = cardsInDeck;
        -:   50:		
     1000:   51:		int hallLocation = rand()%cardsInHand;
     1000:   52:		p->hand[player][hallLocation]=great_hall;
     1000:   53:		p->handCount[player]=cardsInHand;
        -:   54:		
        -:   55:		
        -:   56:		int handBefore, handAfter, deckBefore, deckAfter, actionsBefore, actionsAfter;
        -:   57:		
     1000:   58:		handBefore = p->handCount[player];
     1000:   59:		deckBefore = p->deckCount[player];
     1000:   60:		actionsBefore = p->numActions;
        -:   61:		
     1000:   62:		cardEffect(great_hall, 0,0,0, p, hallLocation, 0);
        -:   63:		
     1000:   64:		handAfter = p->handCount[player];
     1000:   65:		deckAfter = p->deckCount[player];	
     1000:   66:		actionsAfter = p->numActions;
        -:   67:		
        -:   68:		
     1000:   69:		if((handAfter==handBefore) && (deckBefore == deckAfter + 1) && (actionsAfter == actionsBefore+1)){passes++;}
      102:   70:		else if((deckAfter == 0) && (handAfter == handBefore + deckBefore -1)&&(actionsAfter == actionsBefore+1)){passes++;}
        -:   71:		else{
    #####:   72:			fails++;
        -:   73:		
    #####:   74:			printf("\nFailure: test");
    #####:   75:			printf("\nbefore call handCount = %d   ", handBefore);
    #####:   76:			printf("deckCount = %d   \n",deckBefore);
    #####:   77:			printf("actionCount = %d   \n",actionsBefore);
        -:   78:		
    #####:   79:			printf("after call handCount = %d   ", handAfter);
    #####:   80:			printf("deckCount = %d   \n", deckAfter);
    #####:   81:			printf("actionCount = %d   \n",actionsAfter);
        -:   82:		}
        -:   83:	
        -:   84:	
        -:   85:	
        -:   86:	}
        -:   87:	
        -:   88:	
        -:   89:		
        -:   90:			//result output
        1:   91:			printf("\n\n Test Complete: %d passes,  %d fails",passes,fails);
        -:   92:	
        -:   93:
        -:   94:
        1:   95:return 0;
        -:   96:}
        -:   97:
